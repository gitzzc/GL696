/* Includes ------------------------------------------------------------------*/

#include "stdlib.h"
#include "stdio.h"
#include "string.h"

/* Scheduler includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

#include "stm32f10x.h"
#include "keyboard.h"
#include "lcd.h"
#include "window.h"
#include "win_main.h"

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
    
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/


#define WIN_MSG_QSIZE 8
static xQueueHandle xWinMsg_Queue;
static psWindow pCurWin;

unsigned portBASE_TYPE Win_GetMsg(uint16_t *msg, portTickType xBlockTime )
{
	if( xQueueReceive( xWinMsg_Queue, msg, xBlockTime ) )
		return pdTRUE;
	else
		return pdFALSE;
}


unsigned portBASE_TYPE Win_PutMsg(uint16_t msg)
{
	if( xQueueSend( xWinMsg_Queue, &msg, 0 ) != pdPASS )
		return pdFALSE;
	else
		return pdTRUE;	
}

unsigned portBASE_TYPE Win_Init(void)
{
	prvConfigureLCD();

	//LCD_DrawMonoPict( ( unsigned portLONG * ) pcBitmap );
	/* Set the Back Color */
	LCD_SetBackColor( Black );
	/* Set the Text Color */
	LCD_SetTextColor( 0x421F );

	/* Create the queues */
	xWinMsg_Queue = xQueueCreate( WIN_MSG_QSIZE, ( portBASE_TYPE ) sizeof( uint16_t ) );
	if ( xWinMsg_Queue == 0 ){
		return pdFALSE;
	}

	pCurWin = &win_main;
	Win_PutMsg(MSG_WIN_DRAW);
	return pdTRUE;
}


void Win_SetFront(psWindow pswin)
{
   pCurWin = pswin;
   Win_PutMsg(MSG_WIN_DRAW);
}

void Win_MenuDraw(uint8_t index)
{
	LCD_SetCursor(pCurWin->psMenu[index].XPos,pCurWin->psMenu[index].YPos);
	LCD_DisplayString(pCurWin->psMenu[index].Text);
}

void Win_MenuTask(uint16_t msg)
{
	portBASE_TYPE i;

	if ( msg == 0 || pCurWin->psMenu == NULL )
		return;

	switch(msg){
	case MSG_WIN_DRAW:
		for(i=0;pCurWin->psMenu[i].user_msg != MSG_WIN_NULL;i++){
			Win_MenuDraw(i);
		}
		break;
/*	case MSG_WIN_UP:
		if ( pCurWin->curMenu ){
			Win_MenuDraw(pCurWin->curMenu--);
			LCD_SetTextColor(0);
			Win_MenuDraw(pCurWin->curMenu);
			LCD_SetTextColor(1);
		}
		break;
	case MSG_WIN_DOWN:
		if ( pCurWin->psMenu[pCurWin->curMenu+1].user_msg != MSG_WIN_NULL ){
			Win_MenuDraw(pCurWin->curMenu++);
			LCD_SetTextColor(0);
			Win_MenuDraw(pCurWin->curMenu);
			LCD_SetTextColor(1);
		}
		break;
*/	case MSG_WIN_ENTER:
		Win_PutMsg(pCurWin->psMenu[pCurWin->curMenu].user_msg);
		break;
	case MSG_WIN_CANCEL:
		break;
	default:
		for(i=0;pCurWin->psMenu[i].key_msg != MSG_WIN_NULL;i++){
			if ( pCurWin->psMenu[i].key_msg == msg ){
				pCurWin->curMenu = i;
				LCD_SetTextColor(0);
				Win_MenuDraw(i);
				LCD_SetTextColor(1);
				Win_PutMsg(pCurWin->psMenu[i].user_msg);
				break;
			}
		}
		if ( msg & MSG_KEY_BREAK ){
			LCD_SetTextColor(1);
			Win_MenuDraw(pCurWin->curMenu);
		}
		break;
	}

	return;
}

void LineMenu_repaint(psMenu menu,uint8_t index)
{
	if ( menu->curt == index )
		LCD_SetTextColor(0);
	if ( menu->item[index].paint ){
		LCD_SetCursor(menu->startX + strlen(menu->item[index].Text),menu->startY);
		menu->item[index].paint();
	}
	if ( menu->curt == index )
		LCD_SetTextColor(1);
	
}

void LineMenu_Draw(psLineMenuItem item )
{
	LCD_DisplayString(item->Text);
	if ( item->paint != NULL )
		item->paint();
}

void LineMenu_Task( psMenu menu ,uint16_t msg)
{
	portBASE_TYPE i;
	portBASE_TYPE first,curt;

	if ( msg == 0 )
		return;
		
	first = menu->first;
	curt = menu->curt;

	switch(msg){
	case MSG_WIN_DRAW:
		LCD_SetCursor(menu->startX,menu->startY);
		for(i=first;i<first+menu->lines && menu->item[i].Text != NULL;i++){
			if ( curt == i ){
				LCD_SetTextColor(0);
				LineMenu_Draw(&menu->item[i]);
				LCD_SetTextColor(1);
			} else {
				LineMenu_Draw(&menu->item[i]);
			}
			LCD_SetCursor(menu->startX,LCD_GetCursorY()+16);
		}
		break;
	case MSG_WIN_REFRESH:
		LCD_SetCursor(menu->startX,menu->startY+(curt-first)*16);
		LCD_SetTextColor(0);
		LineMenu_Draw(&menu->item[curt]);
		LCD_SetTextColor(1);
		break;	
	case MSG_WIN_UP:
		if ( curt == 0 )
			break;
		LCD_SetCursor(menu->startX,menu->startY+(curt-first)*16);
		if ( curt > first && curt < first + menu->lines ){
			LineMenu_Draw(&menu->item[curt--]);
			LCD_SetTextColor(0);
			LCD_SetCursor(menu->startX,LCD_GetCursorY()-16);
			LineMenu_Draw(&menu->item[curt]);
			LCD_SetTextColor(1);
		} else if ( curt == first ) {
			curt --;
			LCD_SetCursor(menu->startX,menu->startY);
			LCD_SetTextColor(0);
			LineMenu_Draw(&menu->item[curt]);
			LCD_SetTextColor(1);
			for(i=1;i<menu->lines;i++){
				LCD_SetCursor(menu->startX,LCD_GetCursorY()+16);
				LineMenu_Draw(&menu->item[i]);
			}
			first--;
		} else {
			curt = 0;
			first = 0;
		}
		break;
	case MSG_WIN_DOWN:
		if ( curt >= first && curt < first + menu->lines - 1 ){
			LCD_SetCursor(menu->startX,menu->startY+(curt-first)*16);
			LineMenu_Draw(&menu->item[curt++]);
			LCD_SetTextColor(0);
			LCD_SetCursor(menu->startX,LCD_GetCursorY()+16);
			LineMenu_Draw(&menu->item[curt]);
			LCD_SetTextColor(1);
		} else if ( curt == first + menu->lines - 1 ) {
			if ( menu->item[curt+1].Text != NULL ){
				curt++;
				LCD_SetCursor(menu->startX,menu->startY);
				for(i=0;i<menu->lines-1;i++){
					LineMenu_Draw(&menu->item[curt-menu->lines+1+i]);
					LCD_SetCursor(menu->startX,LCD_GetCursorY()+16);
				}
				LCD_SetTextColor(0);
				LineMenu_Draw(&menu->item[curt]);
				LCD_SetCursor(menu->startX,LCD_GetCursorY()+16);
				LCD_SetTextColor(1);
				first ++;
			}
		} else {
			curt = 0;
			first = 0;
		}		
		break;
	case MSG_WIN_ENTER:
		//Win_PutMsg(menu[curt].user_msg);
		break;
	case MSG_WIN_CANCEL:
		break;
	default:
		for(i=0;menu->item[i].Text != NULL;i++){
			if ( menu->item[i].shortcut == msg && menu->item[i].msg ){
				Win_PutMsg( menu->item[i].msg );
				break;
			}
		}
		break;
	}

	menu->first = first;
	menu->curt = curt;

}

portTASK_FUNCTION( WinTask, pvParameters )
{
	uint16_t msg;
 	portTickType xLastWakeTime;
	unsigned portBASE_TYPE sec = 0;
	char str[32];

	( void ) pvParameters;
	
	if ( Win_Init() == pdFALSE )
		return ;
		
	xLastWakeTime = xTaskGetTickCount ();

	while( 1 ){
		while( Win_GetMsg(	&msg, 0) ){
 			if ( pCurWin->Dispatch ) {
				pCurWin->Dispatch( msg );
			}
		}
		if ( KB_Get(&msg,configTICK_RATE_HZ/WINDOW_SEC) == pdTRUE ){
			sprintf(str,"get key:%#x\r\n",msg);
			vSerialPutString(NULL,str,0);
			
			if ( pCurWin->Dispatch ) {
				pCurWin->Dispatch( msg );
			}
		} 

		if ( (sec++ % (WINDOW_SEC/2)) == 0 ){
			Win_PutMsg(MSG_WIN_REFRESH);
		}
		vTaskDelayUntil( &xLastWakeTime, configTICK_RATE_HZ/WINDOW_SEC );
	}
}



